#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <winsock2.h>
#include <Windows.h>
#include <iphlpapi.h>
#include <tlhelp32.h>
#include <winternl.h>
//#pragma comment(lib, "kernel32.dll")
//#pragma comment(lib, "IPHLPAPI.dll")
//#pragma comment(lib, "Ws2_32.lib")

DWORD __stdcall unicode_ror13_hash(const WCHAR* unicode_string);
DWORD __stdcall ror13_hash(const char* string);
HMODULE __stdcall find_kernel32(void);
FARPROC __stdcall find_function(HMODULE module, DWORD hash);

HMODULE __stdcall find_kernel32()
{
    PPEB peb = NULL;
    LDR_DATA_TABLE_ENTRY* module_ptr = NULL, * first_mod = NULL;
    PLIST_ENTRY pListEntry = NULL;

    FARPROC LoadLibraryA = NULL;

    __asm {
        mov eax, fs: [0x30]
        mov peb, eax
    }

    pListEntry = peb->Ldr->InMemoryOrderModuleList.Flink;

    pListEntry = pListEntry->Flink;
    pListEntry = pListEntry->Flink;
    module_ptr = (PLDR_DATA_TABLE_ENTRY)pListEntry;
    return (HMODULE)module_ptr->Reserved2[0];
}

//DWORD __stdcall unicode_ror13_hash(const WCHAR* unicode_string)
//{
//    DWORD hash = 0;
//
//    while (*unicode_string != 0)
//    {
//        DWORD val = (DWORD)*unicode_string++;
//        hash = (hash >> 13) | (hash << 19); // ROR 13
//        hash += val;
//    }
//    return hash;
//}

DWORD __stdcall ror13_hash(const char* string)
{
    DWORD hash = 0;

    while (*string) {
        DWORD val = (DWORD)*string++;
        hash = (hash >> 13) | (hash << 19);  // ROR 13
        hash += val;
    }
    return hash;
}

FARPROC __stdcall find_function(HMODULE module, DWORD hash)
{
    IMAGE_DOS_HEADER* dos_header;
    IMAGE_NT_HEADERS* nt_headers;
    IMAGE_EXPORT_DIRECTORY* export_dir;
    DWORD* names, * funcs;
    WORD* nameords;
    int i;

    dos_header = (IMAGE_DOS_HEADER*)module;
    nt_headers = (IMAGE_NT_HEADERS*)((char*)module + dos_header->e_lfanew);
    export_dir = (IMAGE_EXPORT_DIRECTORY*)((char*)module + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    names = (DWORD*)((char*)module + export_dir->AddressOfNames);
    funcs = (DWORD*)((char*)module + export_dir->AddressOfFunctions);
    nameords = (WORD*)((char*)module + export_dir->AddressOfNameOrdinals);

    for (i = 0; i < export_dir->NumberOfNames; i++)
    {
        char* string = (char*)module + names[i];

        DWORD hashfunc = 0;

        while (*string) {
            DWORD val = (DWORD)*string++;
            hashfunc = (hashfunc >> 13) | (hashfunc << 19);  // ROR 13
            hashfunc += val;
        }

        if (hash == hashfunc)
        {
            WORD nameord = nameords[i];
            DWORD funcrva = funcs[nameord];
            return (FARPROC)((char*)module + funcrva);
        }
    }

    return NULL;
}

int main()
{
    char iphlpapidll[] = { 'I', 'P' ,'H', 'L', 'P', 'A', 'P', 'I', '.', 'D', 'L', 'L', 0x0 };
    char ws2_32dll[] = { 'w' , 's', '2', '_', '3', '2', '.', 'd', 'l', 'l', 0x0 };
    char msvcrtdll[] = { 'm' , 's', 'v', 'c', 'r', 't', '.', 'd', 'l', 'l', 0x0 };
    char ucrtbaseddll[] = { 'u' , 'c', 'r', 't', 'b', 'a','s','e','d', '.', 'd', 'l', 'l', 0x0 };
    char gettcptable2[] = { 'G', 'e', 't', 'T', 'c', 'p', 'T', 'a', 'b', 'l', 'e', '2',  0x0 };
    char ntohs_str[] = { 'n','t','o','h','s',0x0 };
    char kernel_str[] = { 'k', 'e', 'r', 'n', 'e', 'l', '3', '2', '.', 'd', 'l', 'l', 0x0 };
    char loadlibrary[] = { 'L', 'o', 'a','d','L', 'i', 'b','r','a','r','y','A', 0x0 };

    //FILE* (__cdecl * fopen_ptr)(const char*, const char*) = &fopen;
    //FILE* (__cdecl * malloc_ptr)(size_t size) = &malloc;

    ////////FIND KERNEL32.DLL HANDLE//////
    PPEB peb = NULL;
    LDR_DATA_TABLE_ENTRY* module_ptr = NULL, * first_mod = NULL;
    PLIST_ENTRY pListEntry = NULL;

    FARPROC LoadLibraryA = NULL;
    FARPROC GetTcpTable2 = NULL;
    FARPROC ntohs = NULL;
    FARPROC malloc = NULL;
    FARPROC fopen = NULL;
    FARPROC fclose = NULL;
    FARPROC fprintf = NULL;

    __asm {
        mov eax, fs: [0x30]
        mov peb, eax
    }

    pListEntry = peb->Ldr->InMemoryOrderModuleList.Flink;

    pListEntry = pListEntry->Flink;
    pListEntry = pListEntry->Flink;
    module_ptr = (PLDR_DATA_TABLE_ENTRY)pListEntry;
    HMODULE kernel32m = (HMODULE)module_ptr->Reserved2[0];


    ////////////FIND LoadLibraryA////////////
    IMAGE_DOS_HEADER* dos_header;
    IMAGE_NT_HEADERS* nt_headers;
    IMAGE_EXPORT_DIRECTORY* export_dir;
    DWORD* names, * funcs;
    WORD* nameords;
    int i;

    dos_header = (IMAGE_DOS_HEADER*)kernel32m;
    nt_headers = (IMAGE_NT_HEADERS*)((char*)kernel32m + dos_header->e_lfanew);
    export_dir = (IMAGE_EXPORT_DIRECTORY*)((char*)kernel32m + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    names = (DWORD*)((char*)kernel32m + export_dir->AddressOfNames);
    funcs = (DWORD*)((char*)kernel32m + export_dir->AddressOfFunctions);
    nameords = (WORD*)((char*)kernel32m + export_dir->AddressOfNameOrdinals);

    for (i = 0; i < export_dir->NumberOfNames; i++)
    {
        char* string = (char*)kernel32m + names[i];

        DWORD hashfunc = 0;

        while (*string) {
            DWORD val = (DWORD)*string++;
            hashfunc = (hashfunc >> 13) | (hashfunc << 19);  // ROR 13
            hashfunc += val;
        }

        if (0xEC0E4E8E == hashfunc)
        {
            WORD nameord = nameords[i];
            DWORD funcrva = funcs[nameord];
            LoadLibraryA = (FARPROC)((char*)kernel32m + funcrva);
            break;
        }
    }
    ///////LOAD ADDITIONAL LIBRARIES////////////
    HMODULE ws2_32 = LoadLibraryA(ws2_32dll);
    HMODULE iphlpapi = LoadLibraryA(iphlpapidll);
    HMODULE ucrtbased = LoadLibraryA(ucrtbaseddll);
    HMODULE msvcrt = LoadLibraryA(msvcrtdll);
    ////////////FIND GetTcpTable2////////////
    

    dos_header = (IMAGE_DOS_HEADER*)iphlpapi;
    nt_headers = (IMAGE_NT_HEADERS*)((char*)iphlpapi + dos_header->e_lfanew);
    export_dir = (IMAGE_EXPORT_DIRECTORY*)((char*)iphlpapi + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    names = (DWORD*)((char*)iphlpapi + export_dir->AddressOfNames);
    funcs = (DWORD*)((char*)iphlpapi + export_dir->AddressOfFunctions);
    nameords = (WORD*)((char*)iphlpapi + export_dir->AddressOfNameOrdinals);

    for (i = 0; i < export_dir->NumberOfNames; i++)
    {
        char* string = (char*)iphlpapi + names[i];

        DWORD hashfunc = 0;

        while (*string) {
            DWORD val = (DWORD)*string++;
            hashfunc = (hashfunc >> 13) | (hashfunc << 19);  // ROR 13
            hashfunc += val;
        }

        if (0x5D7FD7D6 == hashfunc)
        {
            WORD nameord = nameords[i];
            DWORD funcrva = funcs[nameord];
            GetTcpTable2 = (FARPROC)((char*)iphlpapi + funcrva);
            break;
        }
    }

    ///////FIND NTOHS/////////////
    dos_header = (IMAGE_DOS_HEADER*)ws2_32;
    nt_headers = (IMAGE_NT_HEADERS*)((char*)ws2_32 + dos_header->e_lfanew);
    export_dir = (IMAGE_EXPORT_DIRECTORY*)((char*)ws2_32 + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    names = (DWORD*)((char*)ws2_32 + export_dir->AddressOfNames);
    funcs = (DWORD*)((char*)ws2_32 + export_dir->AddressOfFunctions);
    nameords = (WORD*)((char*)ws2_32 + export_dir->AddressOfNameOrdinals);

    for (i = 0; i < export_dir->NumberOfNames; i++)
    {
        char* string = (char*)ws2_32 + names[i];

        DWORD hashfunc = 0;

        while (*string) {
            DWORD val = (DWORD)*string++;
            hashfunc = (hashfunc >> 13) | (hashfunc << 19);  // ROR 13
            hashfunc += val;
        }

        if (0xEB46FC33 == hashfunc)
        {
            WORD nameord = nameords[i];
            DWORD funcrva = funcs[nameord];
            ntohs = (FARPROC)((char*)ws2_32 + funcrva);
        }
    }
    /////FIND MALLOC/////////////

    dos_header = (IMAGE_DOS_HEADER*)ucrtbased;
    nt_headers = (IMAGE_NT_HEADERS*)((char*)ucrtbased + dos_header->e_lfanew);
    export_dir = (IMAGE_EXPORT_DIRECTORY*)((char*)ucrtbased + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    names = (DWORD*)((char*)ucrtbased + export_dir->AddressOfNames);
    funcs = (DWORD*)((char*)ucrtbased + export_dir->AddressOfFunctions);
    nameords = (WORD*)((char*)ucrtbased + export_dir->AddressOfNameOrdinals);

    for (i = 0; i < export_dir->NumberOfNames; i++)
    {
        char* string = (char*)ucrtbased + names[i];

        DWORD hashfunc = 0;

        while (*string) {
            DWORD val = (DWORD)*string++;
            hashfunc = (hashfunc >> 13) | (hashfunc << 19);  // ROR 13
            hashfunc += val;
        }

        if (0x5B7E2B9A == hashfunc)
        {
            WORD nameord = nameords[i];
            DWORD funcrva = funcs[nameord];
            malloc = (FARPROC)((char*)ucrtbased + funcrva);
            break;
        }
    }

    ////////FIND FOPEN////////////
    dos_header = (IMAGE_DOS_HEADER*)msvcrt;
    nt_headers = (IMAGE_NT_HEADERS*)((char*)msvcrt + dos_header->e_lfanew);
    export_dir = (IMAGE_EXPORT_DIRECTORY*)((char*)msvcrt + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    names = (DWORD*)((char*)msvcrt + export_dir->AddressOfNames);
    funcs = (DWORD*)((char*)msvcrt + export_dir->AddressOfFunctions);
    nameords = (WORD*)((char*)msvcrt + export_dir->AddressOfNameOrdinals);

    for (i = 0; i < export_dir->NumberOfNames; i++)
    {
        char* string = (char*)msvcrt + names[i];

        DWORD hashfunc = 0;

        while (*string) {
            DWORD val = (DWORD)*string++;
            hashfunc = (hashfunc >> 13) | (hashfunc << 19);  // ROR 13
            hashfunc += val;
        }

        if (0xE12E7C6E == hashfunc)
        {
            WORD nameord = nameords[i];
            DWORD funcrva = funcs[nameord];
            fopen = (FARPROC)((char*)msvcrt + funcrva);
            break;
        }
    }

    ////////FIND FCLOSE///////////
    dos_header = (IMAGE_DOS_HEADER*)msvcrt;
    nt_headers = (IMAGE_NT_HEADERS*)((char*)msvcrt + dos_header->e_lfanew);
    export_dir = (IMAGE_EXPORT_DIRECTORY*)((char*)msvcrt + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    names = (DWORD*)((char*)msvcrt + export_dir->AddressOfNames);
    funcs = (DWORD*)((char*)msvcrt + export_dir->AddressOfFunctions);
    nameords = (WORD*)((char*)msvcrt + export_dir->AddressOfNameOrdinals);

    for (i = 0; i < export_dir->NumberOfNames; i++)
    {
        char* string = (char*)msvcrt + names[i];

        DWORD hashfunc = 0;

        while (*string) {
            DWORD val = (DWORD)*string++;
            hashfunc = (hashfunc >> 13) | (hashfunc << 19);  // ROR 13
            hashfunc += val;
        }

        if (0xDB9E4C58 == hashfunc)
        {
            WORD nameord = nameords[i];
            DWORD funcrva = funcs[nameord];
            fclose = (FARPROC)((char*)msvcrt + funcrva);
            break;
        }
    }

    ////////FIND FPRINTF///////////
    dos_header = (IMAGE_DOS_HEADER*)msvcrt;
    nt_headers = (IMAGE_NT_HEADERS*)((char*)msvcrt + dos_header->e_lfanew);
    export_dir = (IMAGE_EXPORT_DIRECTORY*)((char*)msvcrt + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    names = (DWORD*)((char*)msvcrt + export_dir->AddressOfNames);
    funcs = (DWORD*)((char*)msvcrt + export_dir->AddressOfFunctions);
    nameords = (WORD*)((char*)msvcrt + export_dir->AddressOfNameOrdinals);

    for (i = 0; i < export_dir->NumberOfNames; i++)
    {
        char* string = (char*)msvcrt + names[i];

        DWORD hashfunc = 0;

        while (*string) {
            DWORD val = (DWORD)*string++;
            hashfunc = (hashfunc >> 13) | (hashfunc << 19);  // ROR 13
            hashfunc += val;
        }

        if (0xD73F3C1E == hashfunc)
        {
            WORD nameord = nameords[i];
            DWORD funcrva = funcs[nameord];
            fprintf = (FARPROC)((char*)msvcrt + funcrva);
            break;
        }
    }


    PMIB_TCPTABLE2 pTcpTable;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;

    // Call GetTcpTable to get the size of the table
    if (GetTcpTable2(NULL, &dwSize, TRUE) == ERROR_INSUFFICIENT_BUFFER)
    {
        pTcpTable = (PMIB_TCPTABLE2)malloc(dwSize);
        if (pTcpTable == NULL)
        {
            return 1;
        }
    }
    else
    {
        return 1;
    }

    // Call GetTcpTable again to actually get the table
    if ((dwRetVal = GetTcpTable2(pTcpTable, &dwSize, TRUE)) == NO_ERROR)
    {
        FILE* out;
        char out_str[] = { 'o', 'u', 't', '.', 't', 'x', 't', 0x0 };
        char modew[] = { 'w', 0x0 };
        out = fopen(out_str, modew);
        // Loop through the table and print the port numbers
        for (int i = 0; i < (int)pTcpTable->dwNumEntries; i++)
        {
            const char format[] = { '%%', 'd', 0xa, 0x0 };
            if (pTcpTable->table[i].dwState == MIB_TCP_STATE_LISTEN)
            {
                unsigned short port = (u_short)(pTcpTable->table[i].dwLocalPort);
                fprintf(out, format, ntohs(port));
            }
        }
        fclose(out);
    }
    else
    {
        return 1;
    }
    return 0;
}
